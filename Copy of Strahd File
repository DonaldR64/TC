




        
        if (spellName === "Burning Hands") {
            let charID = '-Oe8qdnMHHQEe4fSqqhm';
            let img = getCleanImgSrc("https://files.d20.io/images/105823565/P035DS5yk74ij8TxLPU8BQ/thumb.png?1582679991");
            let target = SpellTarget(caster,"Burning Hands",1,charID,img,5);
            outputCard.body.push("Move Target to 15ft and Centre of Cone, and then Use Macro to Cast");
            PrintCard();
        }



    


    const CastSpell = (msg) => {
        let targetID = msg.selected[0]._id;
        let target = ModelArray[targetID];
        let Tag = msg.content.split(";");
        let spellName = Tag[1];
        let casterID = Tag[2];
        let level = parseInt(Tag[3]);
        let caster = ModelArray[casterID];
        SetupCard(caster.name,spellName,caster.displayScheme);
        let spellInfo = DeepCopy(SpellInfo[spellName]);
        let squares = caster.Distance(target);
        let spellDist = squares * pageInfo.scaleNum;

        if (spellDist > spellInfo.range) {
            outputCard.body.push("Out of Range of Spell");
            PrintCard();
            return;
        }

        if (spellName === "Sleep") {
            //models within 20 ft of centre
            let possibles = AOETargets(target);
            possibles.sort((a,b) => parseInt(a.token.get("bar1_value")) - parseInt(b.token.get("bar1_value"))); // b - a for reverse sort
            let dice = 5 + ((level -1) * 2);
            //5d8 hp. +2d8 for spell level > 1
            let hp = 0;
            let rolls = [];
            for (let i=0;i<dice;i++) {
                let roll = randomInteger(8);
                rolls.push(roll);
                hp += roll;
            }
            let tip = dice + "d8 = " + rolls.toString();
            tip = '[' + hp + '](#" class="showtip" title="' + tip + ')';

            outputCard.body.push(tip + " HP Affected");
            for (let i = 0;i<possibles.length; i++) {
                let possible = possibles[i];
                if (possible.type.includes("undead")) {
                    outputCard.body.push(possible.name + " is Immune");
                    continue;
                };
                if (possible.conditionImmunities.includes("charmed")) {
                    outputCard.body.push(possible.name + " is Immune");
                    continue;
                };
                let posMarkers = Markers(possible.token.get("statusmarkers"));
                if (posMarkers.includes("Unconscious")) {
                    outputCard.body.push(possible.name + " is already Unconscious");
                    continue;
                };

                let phb = parseInt(possibles[i].token.get("bar1_value"));
                if (phb > hp) {
                    outputCard.body.push("[" + possible.name + " HP exceeds remaining]" )
                    break
                };
                hp -= phb;
                outputCard.body.push(possible.name + " Falls Asleep");
                possible.token.set({
                    "status_KO::2006544": true,
                })
            }
            target.Destroy();
            PlaySound("FFire");
        }

        if (spellName === "Entangle") {
            let possibles = AOETargets(target);
            _.each(possibles,model => {
                if (model.conditionImmunities.includes("restrained")) {
                    outputCard.body.push(model.name + " is Immune");
                    return;
                };
                let dc = caster.spellDC;
                let tip;
                let result = Save(model,dc,"strength");
                if (result.save === false) {
                    model.token.set({
                        "status_Restrained-or-Webbed::2006494": true,
                    })
                    tip = '[fails](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " and is restrained");
                } else if (result.save === true) {
                    tip = '[saves](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " and is free to act");                
                }
            })
            target.token.set("layer","map");
            delete ModelArray[targetID]; //leave target token as marks the ground
            outputCard.body.push("[hr]");
            outputCard.body.push("The Area remains Difficult Ground for 1 min or until Concentration ends");
            PlaySound("Entangle");
        }

        if (spellName === "Faerie Fire") {
            let possibles = AOETargets(target);
            _.each(possibles,model => {
                let dc = caster.spellDC;
                let tip;
                let result = Save(model,dc,"dexterity");
                if (result.save === false) {
                    model.token.set({
                        aura1_radius: 1,
                        aura1_color: "#ff00ff",
                        showplayers_aura1: true,
                    })
                    tip = '[fails](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " and is outlined by Faerie Fire");
                } else if (result.save === true) {
                    tip = '[passes](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip);                
                }
            })
            target.Destroy();
            outputCard.body.push("[hr]");
            outputCard.body.push("The Faerie Fire's effect remain for 1 minute or until Concentration Ends");
            PlaySound("FFire");
        }

        if (spellName === "Thunderwave") {
            let possibles = AOETargets(target);
            let dice = 2 + (level -1);
            let total = 0;
            let rolls = [];
            for (let i=0;i<dice;i++) {
                let roll = randomInteger(8);
                rolls.push(roll);
                total += roll;
            }
            let line = dice + "d8 = [" + rolls.toString() + "]";
            tip = '[' + total + '](#" class="showtip" title="' + line + ')';

            outputCard.body.push("Spell Damage: " + tip);
            outputCard.body.push("[hr]");
            _.each(possibles,model => {
                let dc = caster.spellDC;
                let tip;
                let result = Save(model,dc,"constitution");
                if (result.save === false) {
                    tip = '[fails](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " - takes " + total + " Damage and is pushed 10ft back");
//move token back 10ft, and stop if wall

                } else if (result.save === true) {
                    tip = '[passes](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " - takes " + Math.round(total/2) + " Damage");                
                }
            })
            target.Destroy();
            PlaySound("Thunder");
        }

        if (spellName === "Fog Cloud") {
            target.token.set("layer","map");
            delete ModelArray[targetID]; //leave token
            outputCard.body.push("The Area in the Fog Cloud is Heavily Obscured and Blocks Vision");
            outputCard.body.push("It lasts for 1 hour or until Concentration ends, or a stronger wind blows it apart");
            PlaySound("Woosh");
        }

        if (spellName === "Burning Hands") {
            let targets = Cone(caster,target,15);
            //Roll Damage Routine here
            spawnFxBetweenPoints(new Point(caster.token.get("left"),caster.token.get("top")), new Point(target.token.get("left"),target.token.get("top")), "breath-fire");
            //Damage for group
            let rollResults = RollDamage(spellInfo,false,caster,level);
            let add = "";
            if (rollResults.bonus > 0) {add = "+" + rollResults.bonus};
            if (rollResults.bonus < 0) {add = rollResults.bonus}

            let tip = rollResults.diceText + add + " = " + rollResults.rolls + add;
            tip = "[" + rollResults.total + '](#" class="showtip" title="' + tip + ')';
            outputCard.body.push("Group Damage: " + tip);
            if (spellInfo.note !== "") {
                outputCard.body.push(spellInfo.note);
            }
            outputCard.body.push("[hr]");


            _.each(targets, defender => {
                outputCard.body.push("[B]" + defender.name + "[/b]");
                let damageResults = ApplyDamage(spellInfo,caster,defender,rollResults);
                let tip = damageResults.note;
                tip = '[' + damageResults.total + '](#" class="showtip" title="' + tip + ')';
                outputCard.body.push("Damage: " + tip);
            })

            target.Destroy();
            PlaySound("Flames")


        }










        UseSlot(caster,level);
        PrintCard();
    }











    const AOETargets = (target) => {
        let temp = [];
        _.each(ModelArray,model => {
            if (model.id === target.id) {return}
            if (Venn(target.Squares(),model.Squares()) === true) {
                temp.push(model.id);
            }
        })

        temp = [...new Set(temp)];
        let array = [];
        _.each(temp,id => {
            let model = ModelArray[id];
log(model.name)
            array.push(model);
        })
        return array;
    }

    const Venn = (array1,array2) => {
        //for comparing arrays of squares
        //true if any of array2 are in array
        let a1 = array1.map((e) => e.toLabel());
        let a2 = array2.map((e) => e.toLabel());
        let venn = a2.some(r=> a1.includes(r))
        return venn;
    }








    const SpellTarget = (caster,spellName,level,charID,img,dim) => {
        let abilArray = findObjs({_type: "ability", _characterid: charID});
        //clear old abilities
        for(let a=0;a<abilArray.length;a++) {
            abilArray[a].remove();
        } 
        let action = "!CastSpell;" + spellName + ";" + caster.id + ";" + level;
        AddAbility("Cast " + spellName,action,charID);

        dim = (dim * 70) / pageInfo.scaleNum;

        let newToken = createObj("graphic", {
            left: caster.token.get("left"),
            top: caster.token.get("top"),
            disableTokenMenu: true,
            width: dim, 
            height: dim,  
            name: spellName,
            pageid: caster.token.get("_pageid"),
            imgsrc: img,
            layer: "objects",
            represents: charID,
        })
        toFront(newToken);
        if (newToken) {
            let target = new Model(newToken);
            return target;
        } else {
            sendChat("","Error in CreateObj")
        }
    }



    const Compress = (msg) => {
        if (!msg.selected) {return};
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        let tokenSize = model.token.get("width");
        dis = false;
        if (tokenSize > 70) {
            tokenSize = 70;
            dis = true;
        } else {
            tokenSize = 140;
        }
        model.token.set({
            width: tokenSize,
            height: tokenSize,
        });
        model.token.set("status_Minus::2006420",dis);
    }

    const WildShape = (msg) => {
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        let Tag = msg.content.split(";");
        let cName = Tag[1];
        let shape = Tag[2];
        let shapes = {
        "Haevan": 
            {
                "Human": {
                    cID: "-Ody8dmoHKTxM6niN9LG",
                    img: "https://files.d20.io/images/463992132/4sKX1Ac0NcxdpxAX9018ng/thumb.png?1763068152",
                    bar1: "-OdyYc7uqKpGg597yvCO",
                    size: 1,
                },
                "Brown Bear": {
                    cID: "-Odyv5HzmAOpBiY_xqLO",
                    img: "https://files.d20.io/images/463990089/Iqk-2aGyGG0vePsk4grc3w/thumb.png?1763066944",
                    bar1: "-OdyvFotPve1EeYo5MkH",
                    size: 2,
                    hp: 34,
                },
                "Dire Wolf": {
                    cID: "-OdyaMtaDE-mfvTYRU-r",
                    img: "https://files.d20.io/images/464891291/fS-Ml9i2lwAka5on3lcqZQ/thumb.png?1763664881", 
                    bar1: "-OdyaNgSlFfkYRS5u2_4",
                    size: 2,     
                    hp: 37,     
                }
            },
        

        }

        SetupCard(model.name,"Wild Shape",model.displayScheme);
        if (!shapes[cName][shape]) {
            outputCard.body.push("Shape not yet in Array");
            PrintCard();
            return;
        }
        if (model.race.includes(shape.toLowerCase())) {
            outputCard.body.push("Already in that Form");
            PrintCard();
            return;
        }


        let cID = shapes[cName][shape].cID;
        let img = getCleanImgSrc(shapes[cName][shape].img);
        let size = shapes[cName][shape].size;
        let bar1Link = shapes[cName][shape].bar1;

        if (shape !== "Human") {
            let resource = parseInt(Attribute(cID,"class_resource"));
            if (resource <= 0) {
                outputCard.body.push("Unable to Wild Shape");
                PrintCard();
                return;
            }
        }

        let newChar = getObj("character", cID);
        if (!newChar)  {
            sendChat("","No Char")
            return;
        }

        let hp,hpMax,ac;
        if (shape === "Human") {
            ac = Attribute(cID,"ac");
            hp = parseInt(state.Strahd.wildshape[cName]["hp"]);
            hpMax = parseInt(state.Strahd.wildshape[cName]["hpMax"]);
        } else {
            state.Strahd.wildshape[cName] = {
                hp: model.token.get("bar1_value"),
                hpMax: model.token.get("bar1_max"),
            }
            hp = shapes[cName][shape].hp;
            hpMax = hp;
            ac = Attribute(cID,"npc_ac");
        }

        //create token and link

        let newToken = createObj("graphic", {
            left: model.token.get("left"),
            top: model.token.get("top"),
            width: size * 70, 
            height: size * 70,  
            name: newChar.get("name"),
            showname: true,
            showplayers_name: true,
            showplayers_bar1: true,
            pageid: model.token.get("_pageid"),
            imgsrc: img,
            layer: "objects",
            represents: cID,
            bar1_link: bar1Link,
            bar2_value: ac,
            statusmarkers: model.token.get("statusmarkers"),
        });

        newToken.set({
            bar1_value: hp,
            bar1_max: hpMax,
        })
        if (model.token.get("status_Minus::2006420") === true && shape === "Human") {
            newToken.set("status_Minus::2006420",false);
        }

        toFront(newToken);
        if (newToken) {
            let newModel = new Model(newToken);
        } else {
            sendChat("","Error in CreateObj")
        }

        //remove old token/model
        model.Destroy();

        PlaySound("Roar");
        outputCard.body.push("Wild Shape to " + shape);
        PrintCard();

        //use resource

    }


    const UseItem = (msg) => {
        if (!msg.selected) {return};
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        let Tag = msg.content.split(";");
        let itemName = Tag[1];

        SetupCard(model.name,itemName,model.displayScheme);

        if (itemName === "Potion of Healing") {
            let total = 0;
            let rolls = [];
            for (let i=0;i<2;i++) {
                roll = randomInteger(4);
                rolls.push(roll);
                total += roll;
            }
            total += 2;
            let tip = "Rolls: " + rolls.toString() + " + 2";
            tip = '[' + total + '](#" class="showtip" title="' + tip + ')';

            outputCard.body.push("[B]" + tip + "[/b]" + " HP are restored")
        }







            PrintCard();

    }





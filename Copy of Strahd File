



    const Spell = (msg) => {
        let id = msg.selected[0]._id;
        let caster = ModelArray[id];
        let Tag = msg.content.split(";");
        let spellName = Tag[1];
        let level = Tag[2]; //later can cahnge to be 'Cast at X Level'
        
        SetupCard(caster.name,spellName,caster.displayScheme);
        if (SpellSlots(caster,level) === false) {
            outputCard.body.push("No Available Spell Slots of level " + level);
            PrintCard();
            return;
        }

        if (spellName === "Sleep") {
            //create the sleep token, place on caster, with instructions
            let charID = "-OeJRVLCc-tJuxhw911C";
            let img = getCleanImgSrc("https://files.d20.io/images/464585187/odP4Dv5gqpOgxA4GtmGIMA/thumb.webp?1763427066");
            let target = SpellTarget(caster,"Sleep",level,charID,img,40);
            outputCard.body.push("Place Target and then Use Macro to Cast");
            PrintCard();
        }

        if (spellName === "Entangle") {
            let charID = "-OeJFbyJkH36zRywNsEm";
            let img = getCleanImgSrc("https://files.d20.io/images/464592489/MlFXxUdwYnkx-S5mHam-KQ/thumb.png?1763430837");
            let target = SpellTarget(caster,"Entangle",level,charID,img,20);
            outputCard.body.push("Place Target and then Use Macro to Cast");
            PrintCard();
        }
        
        if (spellName === "Faerie Fire") {
            let charID = "-OeJf7QNTBO0lqtOd6Ac";
            let img = getCleanImgSrc("https://files.d20.io/images/464592488/Ol6oEZ2kLqqfV-fEBHrq5Q/thumb.png");
            let target = SpellTarget(caster,"Faerie Fire",level,charID,img,20);
            outputCard.body.push("Place Target and then Use Macro to Cast");
            PrintCard();
        }

        if (spellName === "Thunderwave") {
            let charID = "-OeJrE-MQDPwPo0KDLtq";
            let img = getCleanImgSrc("https://files.d20.io/images/464597646/OEF2m9OvLSy6J_WrL4Mh7Q/thumb.png?1763433964");
            let target = SpellTarget(caster,"Thunderwave",level,charID,img,15);
            outputCard.body.push("Place Target and then Use Macro to Cast");
            PrintCard();
        }

        if (spellName === "Fog Cloud") {
            let charID = "-OeJzgHWtgd8SummEE5T";
            let img = getCleanImgSrc("https://files.d20.io/images/464601122/Z_72GfzK6nldIvjjv9Kusw/thumb.png?1763436289");
            let dim = 40 + ((level - 1) * 40); //radius is 20 ft so diameter is 40
            let target = SpellTarget(caster,"Fog Cloud",level,charID,img,dim);
            outputCard.body.push("Place Target and then Use Macro to Cast");
            PrintCard();
        }

        if (spellName === "Cure Wounds") {
            let rolls = [];
            let bonus = Math.max(0,(caster.spellDC - 10));
            let total = bonus;
            for (i=0;i<level;i++) {
                let roll = randomInteger(8);
                rolls.push(roll);
                total += roll;
            }
            let tip = level + "d8 + " + bonus + " = [" + rolls.toString() + "] + " + bonus;
            tip = '[' + total + '](#" class="showtip" title="' + tip + ')';
            outputCard.body.push("Cure Wounds Heals for " + tip + " HP");
            PlaySound("Angels");
            UseSlot(caster,level);
            PrintCard();
        }
        
        if (spellName === "Burning Hands") {
            let charID = '-Oe8qdnMHHQEe4fSqqhm';
            let img = getCleanImgSrc("https://files.d20.io/images/105823565/P035DS5yk74ij8TxLPU8BQ/thumb.png?1582679991");
            let target = SpellTarget(caster,"Burning Hands",1,charID,img,5);
            outputCard.body.push("Move Target to 15ft and Centre of Cone, and then Use Macro to Cast");
            PrintCard();
        }

        if (spellName === "Divine Favour") {
            outputCard.body.push("Your prayer empowers you with divine radiance. Until the spell ends, your weapon attacks deal an extra 1d4 radiant damage on a hit.");
            outputCard.body.push("Lasts 1 minute or Concentration");
            caster.token.set("status_yellow",true);
            PrintCard();
        }


    }


    const CastSpell = (msg) => {
        let targetID = msg.selected[0]._id;
        let target = ModelArray[targetID];
        let Tag = msg.content.split(";");
        let spellName = Tag[1];
        let casterID = Tag[2];
        let level = parseInt(Tag[3]);
        let caster = ModelArray[casterID];
        SetupCard(caster.name,spellName,caster.displayScheme);
        let spellInfo = DeepCopy(SpellInfo[spellName]);
        let squares = caster.Distance(target);
        let spellDist = squares * pageInfo.scaleNum;

        if (spellDist > spellInfo.range) {
            outputCard.body.push("Out of Range of Spell");
            PrintCard();
            return;
        }

        if (spellName === "Sleep") {
            //models within 20 ft of centre
            let possibles = AOETargets(target);
            possibles.sort((a,b) => parseInt(a.token.get("bar1_value")) - parseInt(b.token.get("bar1_value"))); // b - a for reverse sort
            let dice = 5 + ((level -1) * 2);
            //5d8 hp. +2d8 for spell level > 1
            let hp = 0;
            let rolls = [];
            for (let i=0;i<dice;i++) {
                let roll = randomInteger(8);
                rolls.push(roll);
                hp += roll;
            }
            let tip = dice + "d8 = " + rolls.toString();
            tip = '[' + hp + '](#" class="showtip" title="' + tip + ')';

            outputCard.body.push(tip + " HP Affected");
            for (let i = 0;i<possibles.length; i++) {
                let possible = possibles[i];
                if (possible.type.includes("undead")) {
                    outputCard.body.push(possible.name + " is Immune");
                    continue;
                };
                if (possible.conditionImmunities.includes("charmed")) {
                    outputCard.body.push(possible.name + " is Immune");
                    continue;
                };
                let posMarkers = Markers(possible.token.get("statusmarkers"));
                if (posMarkers.includes("Unconscious")) {
                    outputCard.body.push(possible.name + " is already Unconscious");
                    continue;
                };

                let phb = parseInt(possibles[i].token.get("bar1_value"));
                if (phb > hp) {
                    outputCard.body.push("[" + possible.name + " HP exceeds remaining]" )
                    break
                };
                hp -= phb;
                outputCard.body.push(possible.name + " Falls Asleep");
                possible.token.set({
                    "status_KO::2006544": true,
                })
            }
            target.Destroy();
            PlaySound("FFire");
        }

        if (spellName === "Entangle") {
            let possibles = AOETargets(target);
            _.each(possibles,model => {
                if (model.conditionImmunities.includes("restrained")) {
                    outputCard.body.push(model.name + " is Immune");
                    return;
                };
                let dc = caster.spellDC;
                let tip;
                let result = Save(model,dc,"strength");
                if (result.save === false) {
                    model.token.set({
                        "status_Restrained-or-Webbed::2006494": true,
                    })
                    tip = '[fails](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " and is restrained");
                } else if (result.save === true) {
                    tip = '[saves](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " and is free to act");                
                }
            })
            target.token.set("layer","map");
            delete ModelArray[targetID]; //leave target token as marks the ground
            outputCard.body.push("[hr]");
            outputCard.body.push("The Area remains Difficult Ground for 1 min or until Concentration ends");
            PlaySound("Entangle");
        }

        if (spellName === "Faerie Fire") {
            let possibles = AOETargets(target);
            _.each(possibles,model => {
                let dc = caster.spellDC;
                let tip;
                let result = Save(model,dc,"dexterity");
                if (result.save === false) {
                    model.token.set({
                        aura1_radius: 1,
                        aura1_color: "#ff00ff",
                        showplayers_aura1: true,
                    })
                    tip = '[fails](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " and is outlined by Faerie Fire");
                } else if (result.save === true) {
                    tip = '[passes](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip);                
                }
            })
            target.Destroy();
            outputCard.body.push("[hr]");
            outputCard.body.push("The Faerie Fire's effect remain for 1 minute or until Concentration Ends");
            PlaySound("FFire");
        }

        if (spellName === "Thunderwave") {
            let possibles = AOETargets(target);
            let dice = 2 + (level -1);
            let total = 0;
            let rolls = [];
            for (let i=0;i<dice;i++) {
                let roll = randomInteger(8);
                rolls.push(roll);
                total += roll;
            }
            let line = dice + "d8 = [" + rolls.toString() + "]";
            tip = '[' + total + '](#" class="showtip" title="' + line + ')';

            outputCard.body.push("Spell Damage: " + tip);
            outputCard.body.push("[hr]");
            _.each(possibles,model => {
                let dc = caster.spellDC;
                let tip;
                let result = Save(model,dc,"constitution");
                if (result.save === false) {
                    tip = '[fails](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " - takes " + total + " Damage and is pushed 10ft back");
//move token back 10ft, and stop if wall

                } else if (result.save === true) {
                    tip = '[passes](#" class="showtip" title="' + result.tip + ')';
                    outputCard.body.push(model.name + " " + tip + " - takes " + Math.round(total/2) + " Damage");                
                }
            })
            target.Destroy();
            PlaySound("Thunder");
        }

        if (spellName === "Fog Cloud") {
            target.token.set("layer","map");
            delete ModelArray[targetID]; //leave token
            outputCard.body.push("The Area in the Fog Cloud is Heavily Obscured and Blocks Vision");
            outputCard.body.push("It lasts for 1 hour or until Concentration ends, or a stronger wind blows it apart");
            PlaySound("Woosh");
        }

        if (spellName === "Burning Hands") {
            let targets = Cone(caster,target,15);
            //Roll Damage Routine here
            spawnFxBetweenPoints(new Point(caster.token.get("left"),caster.token.get("top")), new Point(target.token.get("left"),target.token.get("top")), "breath-fire");
            //Damage for group
            let rollResults = RollDamage(spellInfo,false,caster,level);
            let add = "";
            if (rollResults.bonus > 0) {add = "+" + rollResults.bonus};
            if (rollResults.bonus < 0) {add = rollResults.bonus}

            let tip = rollResults.diceText + add + " = " + rollResults.rolls + add;
            tip = "[" + rollResults.total + '](#" class="showtip" title="' + tip + ')';
            outputCard.body.push("Group Damage: " + tip);
            if (spellInfo.note !== "") {
                outputCard.body.push(spellInfo.note);
            }
            outputCard.body.push("[hr]");


            _.each(targets, defender => {
                outputCard.body.push("[B]" + defender.name + "[/b]");
                let damageResults = ApplyDamage(spellInfo,caster,defender,rollResults);
                let tip = damageResults.note;
                tip = '[' + damageResults.total + '](#" class="showtip" title="' + tip + ')';
                outputCard.body.push("Damage: " + tip);
            })

            target.Destroy();
            PlaySound("Flames")


        }










        UseSlot(caster,level);
        PrintCard();
    }

    const SpellSlots = (caster,level) => {
        if (level === 0) {return true};
        let slots = parseInt(Attribute(caster.charID,"lvl" + level + "_slots_expended")) || 0;
        if (slots === 0) {return false};
        return true;
    }

    const UseSlot = (caster,level) => {
return;
        if (level === 0) {return};
        let slots = parseInt(Attribute(caster.charID,"lvl" + level + "_slots_expended")) || 0;
        slots = Math.max(0,slots - 1);
        AttributeSet(caster.charID,"lvl" + level + "_slots_expended",slots);
        outputCard.body.push("[hr]")
        outputCard.body.push("Level " + level + " Spell Slot Used");
        if (slots === 0) {
            outputCard.body.push("No More of that Level");
        }
    }



    const CastSpell2 = (msg) =>{
        let Tag = msg.content.split(";");
        let spellName = Tag[1];
        let spellInfo = SpellInfo[spellName];
        if (spellInfo) {
            spellInfo = DeepCopy(SpellInfo[spellName]);
            spellInfo.info = "Spell";
        } else {
            sendChat("","Need Spell Info");
            return;
        }
        let attID = Tag[2];
        let level = parseInt(Tag[3]);

        let caster = ModelArray[attID];

        let targetID = Tag[4];
        let target = ModelArray[targetID];

        SetupCard(caster.name,spellName,caster.displayScheme);
        if (SpellSlots(caster,level) === false) {
            outputCard.body.push("No Available Spell Slots of level " + level);
            PrintCard();
            return;
        }

        let squares = caster.Distance(target);
        let spellDist = squares * pageInfo.scaleNum;
        if (spellDist > spellInfo.range) {
            outputCard.body.push("Out of Range of Spell");
            PrintCard();
            return;
        }


        if (spellName === "Shield of Faith") {
            outputCard.body.push("A shimmering field appears and surrounds your target within range, granting it a +2 bonus to AC for the duration.");
            outputCard.body.push("Lasts 10 minutes or Concentration");
            target.token.set({
                aura1_radius: 1,
                aura1_color: "#ffd700",
                showplayers_aura1: true,
            })
            PrintCard();
            PlaySound("Angels")
        }


    }







    const SpellAttack = (msg) => {
        let Tag = msg.content.split(";");
        let spellName = Tag[1];
        let spellInfo = SpellInfo[spellName];
        if (spellInfo) {
            spellInfo = DeepCopy(SpellInfo[spellName]);
            spellInfo.info = "Spell";
        } else {
            sendChat("","Need Spell Info");
            return;
        }
        let attID = Tag[2];
        let level = parseInt(Tag[3]);

        let caster = ModelArray[attID];

        SetupCard(caster.name,spellName,caster.displayScheme);
        if (SpellSlots(caster,level) === false) {
            outputCard.body.push("No Available Spell Slots of level " + level);
            PrintCard();
            return;
        }

        let emote = spellInfo.emote;
        emote = emote.replace("%%C%%",caster.name);
        outputCard.body.push(emote);

        let attAdvantage = 0;


        let attPos = ["Invisible","Advantage"];
        let attNeg = ["Blind","Frightened","Poison","Restrained","Disadvantage"];
        let ignore = ["Incapacitated","Paralyzed","Restrained","Stunned","Unconscious"];
        let attMarkers = Markers(caster.token.get("statusmarkers"));

        //check if next to an enemy token, if so, disadvantage unless is Incapacitated, paralyzed, restrained,stunned,unconsciou
        let ids = Object.keys(ModelArray);
        for (let i=0;i<ids.length;i++) {
            let model2 = ModelArray[ids[i]];
            if (model2.displayScheme !== "NPC") {continue};
            let sm = model2.token.get("statusmarkers");
            for (let j=0;j<ignore.length;j++) {
                if (sm.includes(ignore[j])) {continue};
            }
            let squares = caster.Distance(model2);
            if (squares === 1) {
                attAdvantage = Math.max(-1,attAdvantage -1);
                break;
            }
        }
        for (let i=0;i<attPos.length;i++) {
            if (attMarkers.includes(attPos[i])) {
                attAdvantage = Math.min(1,attAdvantage + 1);
                break;
            }
        }
        for (let i=0;i<attNeg.length;i++) {
            if (attMarkers.includes(attNeg[i])) {
                attAdvantage = Math.max(-1,attAdvantage -1);
                break;
            }
        }

        attAdvantage = Math.min(Math.max(-1,attAdvantage),1);

        let defenders = [];
        for (let i=4;i<(Tag.length + 1);i++) {
            let defender = ModelArray[Tag[i]];
            if (!defender) {continue};
            defenders.push(defender);
        }    
        for (let i=0;i<defenders.length;i++) {
            let defender = defenders[i];
            let defPt = new Point(defender.token.get('left'),defender.token.get('top'));
            outputCard.body.push("[B]" + defender.name + "[/b]");
            let distance = caster.Distance(defender) * pageInfo.scaleNum;
            if (distance > spellInfo.range) {
                outputCard.body.push("Target is Out of Range");
                outputCard.body.push("Distance to Target: " + distance);
                outputCard.body.push("Spell Range: " + spellInfo.range);
                continue;
            }

            let fFire = (defender.token.get("aura1_color") === "#ff00ff" && defender.token.get("aura1_radius") === 1) ? true:false;

            let defAdvantage = (fFire === true) ? 1:0;
            let defMarkers = Markers(defender.token.get("statusmarkers"));
            let defPos = ["Blind","Paralyzed","Restrained","Stunned","Unconscious","Disadvantage"];
            let defNeg = ["Invisible","Dodge","Advantage"];
            for (let i=0;i<defPos.length;i++) {
                if (defMarkers.includes(defPos[i])) {
                    defAdvantage = Math.min(defAdvantage +1, 1);
                    break;
                }
            }
            for (let i=0;i<defNeg.length;i++) {
                if (defMarkers.includes(defNeg[i])) {
                    if (defNeg[i] === "Invisible" && fFire === true) {continue};
                    defAdvantage = Math.max(defAdvantage -1,-1);
                    break;
                }
            }
            if (defMarkers.includes("Prone")) {
                if (distance <= 5) {
                    defAdvantage = Math.min(defAdvantage +1, 1);
                } else {
                    defAdvantage = Math.max(defAdvantage -1,-1);
                }
            }

            creatTypes = ["Aberration","Celestial","Elemental","Fey","Fiend","Undead"];
            if (defMarkers.includes("Protection") && creatTypes.includes(caster.type)) {
                defAdvantage = Math.max(defAdvantage -1,-1);
            }

            defAdvantage = Math.min(Math.max(-1,defAdvantage),1);
log("Def Adv: " + defAdvantage)

            let advantage = attAdvantage + defAdvantage;
            advantage = Math.min(Math.max(-1,advantage),1);
log("Final Adv: " + advantage)

            let result = ToHit(advantage);
            let total = result.roll + caster.spellAttack;
            let tip;
            let crit = false;
            if ((defMarkers.includes("Paralyzed") || defMarkers.includes("Unconscious")) && distance <= 5) {
                crit = true;
            }
            if (spellInfo.auto === true) {
                result.roll = 21;
            } else {
                tip = result.rollText + " + " + caster.spellAttack;
                tip = '[' + total + '](#" class="showtip" title="' + tip + ')';
                line = "Attack: " + tip + " vs. AC " + defender.ac;
                if (result.roll === 20) {
                    crit = true;
                }
                outputCard.body.push(line);
            }

            if ((total >= defender.ac || spellInfo.auto === true || crit === true) && result.roll !== 1) {
                if (crit === true) {
                    outputCard.body.push("[#ff0000]Crit![/#]");
                }   
                let rollResults = RollDamage(spellInfo,crit,caster,level);
                let damageResults = ApplyDamage(spellInfo,caster,defender,rollResults);
                let add = "";
                if (rollResults.bonus > 0) {
                    add = "+" + rollResults.bonus;
                }
                if (rollResults.bonus < 0) {
                    add = rollResults.bonus;
                }
                let tip = rollResults.diceText + add + " = " + rollResults.rolls + add;
                if (damageResults.note !== "") {
                    tip += "<br>" + damageResults.note;
                }
                tip = '[' + damageResults.total + '](#" class="showtip" title="' + tip + ')';
                outputCard.body.push("Damage: " + tip);
                if (spellInfo.note !== "") {
                    outputCard.body.push(spellInfo.note);
                }


            } else {
                outputCard.body.push("[B]Miss[/b]");
            }
            if (defenders.length > 1) {
                outputCard.body.push("[hr]");
            }

            if (i===0) {
                PlaySound(spellInfo.sound);
            }




        }

        UseSlot(caster,level);
        PrintCard();







        





    }


    const TokenInfo = (msg) => {
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        if (!id || !model) {return}
        let token = model.token;
        SetupCard(model.name,"","NPC");
        let pt = new Point(token.get("left"),token.get("left"));
        let squares = model.Squares();
        outputCard.body.push("Point: " + pt.x + "/" + pt.y)
        _.each(squares,square => {
            outputCard.body.push("Square: " + square.x + "/" + square.y)
        })
        let char = getObj("character", token.get("represents"));    

        
        PrintCard();

    }




    const AddAbility = (abilityName,action,charID) => {
        createObj("ability", {
            name: abilityName,
            characterid: charID,
            action: action,
            istokenaction: true,
        })
    }    

    const AOETargets = (target) => {
        let temp = [];
        _.each(ModelArray,model => {
            if (model.id === target.id) {return}
            if (Venn(target.Squares(),model.Squares()) === true) {
                temp.push(model.id);
            }
        })

        temp = [...new Set(temp)];
        let array = [];
        _.each(temp,id => {
            let model = ModelArray[id];
log(model.name)
            array.push(model);
        })
        return array;
    }

    const Venn = (array1,array2) => {
        //for comparing arrays of squares
        //true if any of array2 are in array
        let a1 = array1.map((e) => e.toLabel());
        let a2 = array2.map((e) => e.toLabel());
        let venn = a2.some(r=> a1.includes(r))
        return venn;
    }






    const SavingThrow = (msg) => {
        if (!msg.selected) {
            sendChat("","Select a Token");
            return;
        };
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        let Tag = msg.content.split(";");
        let advantage = (Tag[1] === "Advantage") ? 1: (Tag[1] === "Disadvantage") ? -1:0;
        let stat = Tag[2];
        let statTLC = stat.toLowerCase();

        SetupCard(model.name,stat,model.displayScheme);

        let result = Save(model,false,statTLC,advantage);
        let c1 = "",c2 = "";
        if (result.saveRoll === 20) {
            c1 = "[#008000]";
            c2 = "[/#]";
        }
        if (result.saveRoll === 1) {
            c1 = "[#ff0000]";
            c2 = "[/#]";
        }
  
        outputCard.body.push("[B]Result: " + result.saveTotal + "[/b]");
        outputCard.body.push("[hr]");

        let line = "Roll: " + c1 + result.saveRoll + c2;
        if (result.finalAdv !== 0) {
            line += "/[" + result.altRoll + "]";
        }

        line += " Bonus: ";
        if (result.bonus >= 0) {
            line += "+" + result.bonus;
        } else {
            line += result.bonus;
        }
        line += result.otherBonusText;

        outputCard.body.push(line);
        if (result.finalAdv === 1) {
            line = "[Advantage";
            if (result.advReasons !== "") {
                line + ": " + result.advReasons + "]";
            }
            outputCard.body.push(line);
        }
        if (result.finalAdv === -1) {
            line = "[Disadvantage";
            if (result.disAdvReasons !== "") {
                line + ": " + result.disAdvReasons + "]";
            }
            outputCard.body.push(line);
        }

        let inc = ["Paralyzed","Stunned","Unconscious"];            

        if (model.name.includes("Wirsten") && statTLC === "dexterity") {
            let sm = model.token.get("statusmarkers");
            //incapacitated - means skip
            let skip = false;
            _.each(inc,c => {
                if (sm.includes(c)) {
                    skip = true;
                }
            })
            if (skip === false) {
                outputCard.body.push("[hr]");
                outputCard.body.push("Shield Master: You can add 2 to your Result if the Spell/Harmful Effect targets only you");
                outputCard.body.push("If you save and would take 1/2 Damage, you can use your Reaction to take No Damage, interposing your Shield");
            }
        }

        PlaySound("Dice");

        PrintCard();

    }


    const Initiative = (msg) => {
        if (!msg.selected) {
            sendChat("","Select a Token");
            return;
        };
        let id = msg.selected[0]._id;
        let model = ModelArray[id];

        SetupCard(model.name,"Initiative",model.displayScheme);
        let bonus = model.initBonus;
        let roll = randomInteger(20);
        let result = roll + bonus;
        let tip = "Roll: " + roll + " + " + bonus;
        tip = '[' + result + '](#" class="showtip" title="' + tip + ')';
        outputCard.body.push("Initiative Result: " + tip);
        PrintCard();

        if (Campaign().get("turnorder") == "") {
            turnorder = [];
        } else {
            turnorder = JSON.parse(Campaign().get("turnorder"));
        }
        turnorder.push({
            _pageid:    model.token.get("_pageid"),
            id:         id,
            pr:         result,
            formula:    "-1"
        });
        turnorder.sort((a,b) => b.pr - a.pr);
        Campaign().set("turnorder", JSON.stringify(turnorder));
        PlaySound("Dice")
    }


    const Check = (msg) => {
        if (!msg.selected) {
            sendChat("","Select a Token");
            return;
        };
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        let Tag = msg.content.split(";");
        let advantage = (Tag[1] === "Advantage") ? 1: (Tag[1] === "Disadvantage") ? -1:0;
        let text = Tag[2];
        let skill = text.toLowerCase();
        skill = skill.replace(" ","_");
        SetupCard(model.name,text,model.displayScheme);

        let stats = ["strength","dexterity","constitution","intelligence","wisdom","charisma"];

        let bonus;
        if (stats.includes(skill)) {
            bonus = model.statBonus[skill];
        } else {
            bonus = model.skills[skill];
        }

        let roll1 = randomInteger(20);
        let roll2 = randomInteger(20);
        let altRoll;

        let roll = roll1;
        if (advantage === 1) {
            roll = Math.max(roll1,roll2);
            altRoll = Math.min(roll1,roll2);
        }
        if (advantage === -1) {
            roll = Math.min(roll1,roll2);
            altRoll = Math.max(roll1,roll2);
        }
        let rollTotal = Math.max(roll + bonus,1);
        let c1 = "",c2 = "";
        if (roll === 20) {
            c1 = "[#008000]";
            c2 = "[/#]";
        }
        if (roll === 1) {
            c1 = "[#ff0000]";
            c2 = "[/#]";
        }

        outputCard.body.push("[B]" + c1 + "Result: " + rollTotal + "[/b]" + c2);
        outputCard.body.push("[hr]");

        let line = "Roll: " + c1 + roll + c2;
        if (advantage !== 0) {
            line += "/[" + altRoll + "]";
        }

        line += " Bonus: ";
        if (bonus >= 0) {
            line += "+" + bonus;
        } else {
            line += bonus;
        }
        outputCard.body.push(line);

        if (advantage === 1) {
            outputCard.body.push("[Advantage]");
        }
        if (advantage === -1) {
            outputCard.body.push("[Disadvantage]");
        }

        PlaySound("Dice")

        PrintCard();

    }

    
    const ReloadTokens = (msg) => {
        let ids = [];
        _.each(msg.selected,s => {
            ids.push(s._id);
        })
        _.each(ids,id => {
            let token = findObjs({_type:"graphic", id: id})[0];
            if (token) {
                let m = new Model(token);
            }
        })
        sendChat("","/w GM Reloaded")
    }




        


    const SpellTarget = (caster,spellName,level,charID,img,dim) => {
        let abilArray = findObjs({_type: "ability", _characterid: charID});
        //clear old abilities
        for(let a=0;a<abilArray.length;a++) {
            abilArray[a].remove();
        } 
        let action = "!CastSpell;" + spellName + ";" + caster.id + ";" + level;
        AddAbility("Cast " + spellName,action,charID);

        dim = (dim * 70) / pageInfo.scaleNum;

        let newToken = createObj("graphic", {
            left: caster.token.get("left"),
            top: caster.token.get("top"),
            disableTokenMenu: true,
            width: dim, 
            height: dim,  
            name: spellName,
            pageid: caster.token.get("_pageid"),
            imgsrc: img,
            layer: "objects",
            represents: charID,
        })
        toFront(newToken);
        if (newToken) {
            let target = new Model(newToken);
            return target;
        } else {
            sendChat("","Error in CreateObj")
        }
    }


    const Info = (msg) => {
        if (!msg.selected) {return};
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        if (!model) {
            sendChat("","Not in Array")
        } else {
            sendChat("",model.name);
        }


    }

    const Compress = (msg) => {
        if (!msg.selected) {return};
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        let tokenSize = model.token.get("width");
        dis = false;
        if (tokenSize > 70) {
            tokenSize = 70;
            dis = true;
        } else {
            tokenSize = 140;
        }
        model.token.set({
            width: tokenSize,
            height: tokenSize,
        });
        model.token.set("status_Minus::2006420",dis);
    }

    const WildShape = (msg) => {
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        let Tag = msg.content.split(";");
        let cName = Tag[1];
        let shape = Tag[2];
        let shapes = {
        "Haevan": 
            {
                "Human": {
                    cID: "-Ody8dmoHKTxM6niN9LG",
                    img: "https://files.d20.io/images/463992132/4sKX1Ac0NcxdpxAX9018ng/thumb.png?1763068152",
                    bar1: "-OdyYc7uqKpGg597yvCO",
                    size: 1,
                },
                "Brown Bear": {
                    cID: "-Odyv5HzmAOpBiY_xqLO",
                    img: "https://files.d20.io/images/463990089/Iqk-2aGyGG0vePsk4grc3w/thumb.png?1763066944",
                    bar1: "-OdyvFotPve1EeYo5MkH",
                    size: 2,
                    hp: 34,
                },
                "Dire Wolf": {
                    cID: "-OdyaMtaDE-mfvTYRU-r",
                    img: "https://files.d20.io/images/464891291/fS-Ml9i2lwAka5on3lcqZQ/thumb.png?1763664881", 
                    bar1: "-OdyaNgSlFfkYRS5u2_4",
                    size: 2,     
                    hp: 37,     
                }
            },
        

        }

        SetupCard(model.name,"Wild Shape",model.displayScheme);
        if (!shapes[cName][shape]) {
            outputCard.body.push("Shape not yet in Array");
            PrintCard();
            return;
        }
        if (model.race.includes(shape.toLowerCase())) {
            outputCard.body.push("Already in that Form");
            PrintCard();
            return;
        }


        let cID = shapes[cName][shape].cID;
        let img = getCleanImgSrc(shapes[cName][shape].img);
        let size = shapes[cName][shape].size;
        let bar1Link = shapes[cName][shape].bar1;

        if (shape !== "Human") {
            let resource = parseInt(Attribute(cID,"class_resource"));
            if (resource <= 0) {
                outputCard.body.push("Unable to Wild Shape");
                PrintCard();
                return;
            }
        }

        let newChar = getObj("character", cID);
        if (!newChar)  {
            sendChat("","No Char")
            return;
        }

        let hp,hpMax,ac;
        if (shape === "Human") {
            ac = Attribute(cID,"ac");
            hp = parseInt(state.Strahd.wildshape[cName]["hp"]);
            hpMax = parseInt(state.Strahd.wildshape[cName]["hpMax"]);
        } else {
            state.Strahd.wildshape[cName] = {
                hp: model.token.get("bar1_value"),
                hpMax: model.token.get("bar1_max"),
            }
            hp = shapes[cName][shape].hp;
            hpMax = hp;
            ac = Attribute(cID,"npc_ac");
        }

        //create token and link

        let newToken = createObj("graphic", {
            left: model.token.get("left"),
            top: model.token.get("top"),
            width: size * 70, 
            height: size * 70,  
            name: newChar.get("name"),
            showname: true,
            showplayers_name: true,
            showplayers_bar1: true,
            pageid: model.token.get("_pageid"),
            imgsrc: img,
            layer: "objects",
            represents: cID,
            bar1_link: bar1Link,
            bar2_value: ac,
            statusmarkers: model.token.get("statusmarkers"),
        });

        newToken.set({
            bar1_value: hp,
            bar1_max: hpMax,
        })
        if (model.token.get("status_Minus::2006420") === true && shape === "Human") {
            newToken.set("status_Minus::2006420",false);
        }

        toFront(newToken);
        if (newToken) {
            let newModel = new Model(newToken);
        } else {
            sendChat("","Error in CreateObj")
        }

        //remove old token/model
        model.Destroy();

        PlaySound("Roar");
        outputCard.body.push("Wild Shape to " + shape);
        PrintCard();

        //use resource

    }


    const UseItem = (msg) => {
        if (!msg.selected) {return};
        let id = msg.selected[0]._id;
        let model = ModelArray[id];
        let Tag = msg.content.split(";");
        let itemName = Tag[1];

        SetupCard(model.name,itemName,model.displayScheme);

        if (itemName === "Potion of Healing") {
            let total = 0;
            let rolls = [];
            for (let i=0;i<2;i++) {
                roll = randomInteger(4);
                rolls.push(roll);
                total += roll;
            }
            total += 2;
            let tip = "Rolls: " + rolls.toString() + " + 2";
            tip = '[' + total + '](#" class="showtip" title="' + tip + ')';

            outputCard.body.push("[B]" + tip + "[/b]" + " HP are restored")
        }







            PrintCard();

    }






    const Save = (model,dc,stat,adv) => {
        let saved = false;
        if (!adv) {adv = 0;}
        let fail = false;
        let advReasons = [];
        let disAdvReasons = [];
        let failReason = "";
        let bonus = model.saveBonus[stat];
        let saveRoll1 = randomInteger(20);
        let saveRoll2 = randomInteger(20);
        let sm = Markers(model.token.get("statusmarkers"));
        let inc = ["Paralyzed","Stunned","Unconscious"];
        if (stat === "strength" || stat === "dexterity") {
            _.each(inc,c => {
                if (sm.includes(c)) {
                    fail = true;
                    failReason = c;
                }
            })
        }

        let modelMarkers = Markers(model.token.get("statusmarkers"));
        let otherBonusText = "";
        let otherBonus = 0;
        if (modelMarkers.includes("Bless")) {
            otherBonus = randomInteger(4);
            otherBonusText += " +" + otherBonus + " [Bless d4]";
        }
        bonus += otherBonus;



        if (sm.includes("Dodge") && stat === "dexterity") {
            adv = Math.min(adv + 1,1);
            advReasons.push("Dodge");
        }

        if (sm.includes("Restrained") && stat === "dexterity") {
            adv = Math.max(adv - 1, -1);
            disAdvReasons.push("Restrained");
        }

        let saveRoll = saveRoll1;
        let altRoll;
        if (adv === 1) {
            saveRoll = Math.max(saveRoll1,saveRoll2);
            altRoll = Math.min(saveRoll1,saveRoll2);
        }
        if (adv === -1) {
            saveRoll = Math.min(saveRoll1,saveRoll2);
            altRoll = Math.max(saveRoll1,saveRoll2);
        }
        let saveTotal = Math.max(saveRoll + bonus,1);

        let saveTip = "<br>Roll: " + saveRoll + " + " + bonus;

        if (adv === 1) {
            saveTip += "<br>Advantage: " + saveRoll1 + "/" + saveRoll2;
        }
        if (adv === -1) {
            saveTip += "<br>Disadvantage: " + saveRoll1 + "/" + saveRoll2;
        }
        if (advReasons.length > 0) {
            saveTip += "<br>" + advReasons.toString();
        }
        if (disAdvReasons.length > 0) {
            saveTip += "<br>" + disAdvReasons.toString();
        }

        if (dc !== false) {
            if ((saveTotal >= dc || saveRoll === 20) && saveRoll !== 1) {
                saved = true;
            } 
            saveTip = "Save: " + saveTotal + " vs. DC " + dc + saveTip;
            if (fail === true) {
                saved = false,
                saveTip = "Automatically Failed Save due to " + failReason;
            }

        } 

        let result = {
            save: saved,
            saveRoll: saveRoll,
            altRoll: altRoll,
            bonus: bonus,
            otherBonusText: otherBonusText,
            saveTotal:saveTotal,
            advReasons: advReasons,
            disAdvReasons: disAdvReasons,
            tip: saveTip,
            fail: fail,
            failReason: failReason,
            finalAdv: adv,
        }
        return result;
    }


    const changeGraphic = (tok,prev) => {
        let model = ModelArray[tok.id];
        if (!model) {
            let char = getObj("character", tok.get("represents")); 
            if (char) {
                addGraphic(tok);
            }
        }
    }







    const addGraphic = (obj) => {
        log("Add")
        if (obj.get(["pageid"]) === pageInfo.id) {
            if (!obj.get("name")) {
                let char = getObj("character", obj.get("represents")); 
                if (!char) {return};
                obj.set({
                    name: char.get("name")
                })
            }
            let model = new Model(obj);
        }
    }

    const destroyGraphic = (obj) => {
        log("Destroy " + obj.get("name"))
        let model = ModelArray[obj.get("id")];
        if (model) {
            model.Destroy();
        }
    }

    const changePage = () => {
        LoadPage();
        BuildArrays();
        sendChat("","Page Change");
    }



    const handleInput = (msg) => {
        if (msg.type !== "api") {
            return;
        }
        let args = msg.content.split(";");
        log(args);
    
        switch(args[0]) {
            case '!Dump':
                let names = [];
                _.each(ModelArray,model => {
                    names.push(model.name)
                })
                log(names);


                break;
            case '!Smite':
                Smite(msg);
                break;
            case '!ShieldShove':
                ShieldShove(msg);
                break;
            case '!SpellAttack':
                SpellAttack(msg);
                break;
            case '!SetCondition':
                SetCondition(msg);
                break;
            case '!Spell':
                Spell(msg);
                break;
            case '!CastSpell':
                CastSpell(msg);
                break;
            case '!Attack':
                Attack(msg);
                break;
            case '!TokenInfo':
                TokenInfo(msg);
                break;
            case '!SavingThrow':
                SavingThrow(msg);
                break;
            case '!Initiative':
                Initiative(msg);
                break;
            case '!Check':
                Check(msg);
                break;
            case '!Compress':
                Compress(msg);
                break;
            case '!WildShape':
                WildShape(msg);
                break;
            case '!ClearState':
                ClearState();
                break;
            case '!CastSpell2':
                CastSpell2(msg);
                break;
            case '!ReloadTokens':
                ReloadTokens(msg);
                break;
            case '!UseItem':
                UseItem(msg);
                break;


        }
    };




    const registerEventHandlers = () => {
        on('chat:message', handleInput);
        on('destroy:graphic',destroyGraphic);
        on('add:graphic',addGraphic);
        on('change:graphic',changeGraphic);
        on('change:campaign:playerpageid',changePage);


    };
    on('ready', () => {
        log("===> CoS <===");
        log("===> Software Version: " + version + " <===");
        LoadPage();
        BuildArrays();
        registerEventHandlers();
        sendChat("","API Ready")
        log("On Ready Done")
    });
    return {
        // Public interface here
    };






})();



const Melee = (msg) => {
    let Tag = msg.content.split(";");
    let attackerID = Tag[1];
    let defenderID = Tag[2];
    let weaponNum = Tag[3];
    let secondary = Tag[4];
    let extraDice = (secondary === true) ? -1:0; //configure secondary as an addon in addabilities
    let attacker = ModelArray[attackerID];
    let defender = ModelArray[defenderID];
    let weapon = attacker.weaponArray.melee[weaponNum];
log(weapon)

    let errorMsg = [];
    let distance = attacker.cube.distance(defender.cube);
    let minimum = 1;
    if (attacker.size === "Large" || defender.size === "Large") {
        minimum = 2;
    }
    if (distance > minimum) {
        errorMsg.push("Target is Out of Range");
    }
    //bit about having fired assault weapon here

    SetupCard(shooter.name,weapon.name,shooter.faction);
    //errors re range, los
    if (errorMsg.length > 0) {
        _.each(errorMsg,msg => {
            outputCard.body.push(msg);
        })
        PrintCard();
        return;
    }

    attackInfo = {
        attacker: attacker,
        defender: defender,
        weapon: weapon,
        extraDice: extraDice,
        result: "",
    }
    let check = CheckMarkers(shooterID,"Melee2");
    if (check === true) {
        //has markers
        PrintCard();
        return;
    }
    Melee2(0);
}

const Melee2 = (extraDice) => {
    //entry from Melee or from Marker
    let attacker = attackInfo.attacker;
    let defender = attackInfo.defender;
    let weapon = attackInfo.weapon;
    let secondaryDice = attackInfo.extraDice;
    SetupCard(shooter.name,weapon.name,shooter.faction);
    let tip;

    //To Hit
    //attacker modifiers
    if (attacker.meleeBonus > 0) {
        tip = "<br>Base: +" + attacker.meleeBonus + " Dice";
    } else {
        tip = "Base: " + attacker.meleeBonus + " Dice";
    }
    if (extraDice !== 0) {
        tip += "<br>Markers: " + extraDice + " Dice"; 
    }
    if (secondaryDice !== 0) {
        tip += "<br>Secondary Weapon -1 Dice";
        extraDice -= 1;
    }
    extraDice += shooter.rangedBonus;

    let fearImmune = false;
    for (let i=0;i<attacker.abilityArray.length;i++) {
        let ability = defender.abilityArray[i].name;
        if (ability === "Fear") {
            fearImmune = true;
        }
        //other fear immune here?
    }





    //weapon modifiers
    let mods = weapon.modifiers;
    _.each(mods,mod => {
        let sign = 1;
        if (mod.includes("-")) {
            sign = -1;
        }
        if (mod.includes("Hit")) {
            let text = (mod.includes("-")) ? "":"+"
            let bonus = sign * parseInt(mod)
            extraDice += bonus;
            tip += "<br>Weapon: " + text + bonus + " Dice";
        }

    })

    //defender abilities
    for (let i=0;i<defender.abilityArray.length;i++) {
        let ability = defender.abilityArray[i].name;
        if (ability === "Fear" && fearImmune === false) {
            extraDice -= 1;
            tip += "<br>Defender Causes Fear"
        }
    }


    //defender obstacle
    let defendedObstacle = false;
    let sameTerrain = findCommonElements(hexMap[attacker.hexLabel].terrainIDs,hexMap[defender.hexLabel].terrainIDs);
    if (sameTerrain === false || defender.token.get("aura2_color") !== "#FF0000") {
        let hexes = [hexMap[defender.hexLabel]];
        if (attacker.size === "Large" || defender.size === "Large") {
            let midCube = hexMap[attacker.hexLabel].cube.linedraw(hexMap[defender.hexLabel].cube);
            if (midCube) {
                hexes.push(hexMap[midCube.label()]);
            }
        }
        for (let i=0;i<hexes.length;i++) {
            if (hexes[i].obstacle === true) {
                defendedObstacle = true;
                break;
            }
        }
    }
    if (defendedObstacle === true) {
        tip += "<br>Defended Obstacle: -1 Dice";
        extraDice -= 1;
    }




}


